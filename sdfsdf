Colorban V2.0
TODO: introductie
Basis functionaliteit

1. Parsen/weergeven van een level: Je moet in staat zijn om een Colorban levelconfiguratie in te laden en weer te geven. Een wereld bestaat steeds uit verschillende tegels en entiteiten met elk hun eigen functionaliteiten en eigenschappen. Sommige tegels/entiteiten zijn onbetreedbaar voor een speler (bijv. muren, kisten, leegtes, enz). Andere tegels kunnen dan weer door de speler gebruikt worden om zich te verplaatsen door de wereld en noemen we betreedbaar (bijv. grond, vlekken, opslagplaatsen, tegels met richting, enz).&nbsp;

2. Bewegen door de wereld: De speler moet in staat zijn om vrij door de wereld te bewegen. Aangezien we hier werken met een roosterwereld kan de speler in hoogstens vier richtingen bewegen (links, rechts, boven en onder). De speler moet hierbij steeds de regels van de verschillende tegels opvolgen:

De speler kan niet op onbetreedbare tegels staan
Wanneer een tegel een richting heeft, aangegeven met een pijl, moet de speler deze richting verplicht volgen. Het mag niet mogelijk zijn om in een andere richting te bewegen.
Wanneer de speler geblokkeerd wordt door een ander object (bijv. een andere speler of een kist) kan hij niet verder bewegen in die richting. De speler blijft in dat geval staan op zijn huidige locatie.

3. Verzetten van kisten: Het doel van het spel blijft kisten naar hun juiste eindlocatie verzetten. Naast bewegen, moet de speler de kisten dus ook kunnen verplaatsen binnen elk level. Elke kist heeft een kleur en gewicht, terwijl de speler ook een kleur en maximale kracht heeft. Een kist kan enkel verplaatst worden indien de kleuren overeenkomen en het gewicht van de kist kleiner of gelijk aan dan de maximale kracht van de speler. Het is mogelijk om meerdere kisten tegelijk te verplaatsen wanneer voldaan is aan de volgende twee regels:

De kleur van de eerste kist komt overeen met de kleur van de speler
De som van de kisten is kleiner of gelijk aan de maximale kracht van de speler.

4. Meerdere robots: In tegenstelling tot het eerste project mag de wereld nu meerdere spelers bevatten. De verschillende spelers kunnen gebruikt worden om kisten te verplaatsen of plaats te maken voor elkaar. Het moet steeds mogelijk zijn om te wisselen tussen de verschillende spelers. Hierover geven we later meer informatie.

5. Winnen van het spel: De gebruiker moet enkel kunnen winnen. Wanneer alle kisten en spelers op een correct eindpunt staan, mag je het level als opgelost beschouwen. Wanneer het level is opgelost, moet je een scherm tonen dat dit duidelijk maakt aan de gebruiker. Hierop staat dan de optie om over te gaan naar het volgende level. Wanneer het laatste level wordt opgelost, geef je aan dat de gebruiker heeft gewonnen. Het is niet nodig om na te kijken of een level onoplosbaar is.

6. Gebruikersinterface: Tot slot moet je spel start- en eindschermen aanbieden. Bij de start moet het mogelijk zijn om een level te selecteren. Bij de overgangen van levels moet een scherm getoond worden en op het einde van het spel, wanneer alle levels doorlopen zijn, moet je aangeven dat de speler gewonnen heeft.

Interface

Om het testen van jullie programma eenvoudiger te maken, leggen we de interface voor de besturing vast voor jullie:

R: Resetten van een level

M: Teruggaan naar het startmenu

P: Teruggaan naar de vorige speler

N: Verdergaan naar de volgende speler

Pijltjes:&nbsp;Bewegen doorheen de spelwereld

Enter: Bevestigen van acties (bijv. Op het startscherm of bij overgangen van levels)

Opbouw wereldbestand

TODO

Afhalen en indienen code

TODO: zelfde repo gebruiken?

De skeletcode om je project mee te starten kan je terugvinden via SubGIT. In eerste instantie zal je een account moeten aanmaken via deze link. Daarna kan je de skeletcode&nbsp;afhalen (clonen) door volgende commando’s uit te voeren in je POSIX shell of Git Bash:

git clone git@subgit.ugent.be:2022-2023/fp/rpg_engine/<jouw studentennummer=""> engine
cd engine

Op deze locatie kan je nu het project beginnen oplossen. Als (een klein deeltje van) je project compileert, kan je het meteen pushen naar SubGIT zodat je werk niet verloren gaat moest je computer kapot gaan. Hiervoor maak je eerst een commit (een verzameling van wijzigingen aan je code) die je dan naar de server stuurt (push).

git add src/Main.hs # gewijzigd bestand toevoegen
git commit -m 'haaaaaands' # of een andere omschrijving van je wijzigingen
git push # stuur naar de gekoppelde remote

Lees de uitvoer van je push. Deze zal vertellen of je code correct toegekomen is. Code die niet compileert zal je niet kunnen pushen (maak gebruik van undefined om ontbrekende stukken in te dienen).

Je mag zo vaak pushen als je wilt. Maak hier alsjeblieft gebruik van.

(Kenners van git mogen zich vrij voelen om met meerdere branches, ook remote, te werken. Zorg er gewoon voor dat je finale indiening op master terecht komt.)

Extra bibliotheken en assets

In dit project mag je naast de gebruikelijke afhankelijkheden uit vorige projecten ook gebruik maken van parser-bibliotheken. Je bent met andere woorden vrij om te kiezen voor je eigen parser implementatie of de implementatie van bijvoorbeeld parsec. Deze bibliotheek biedt daarnaast ook een parser transformer (ParsecT) aan die je mag gebruiken in je eigen implementatie.

Om je spel aangenamer te maken, kan je gebruikmaken van game assets. Je mag hiervoor gratis assets van het internet gebruiken (enkel als dit mag onder hun licentie). We vragen je enkel om de locatie van de assets aan te geven in je verslag en eventueel een licentie toe te voegen als deze aanwezig zou zijn bij de assets. Je bent uiteraard ook hier vrij om zelf assets te creëren, maar let op dat je hier niet te veel tijd aan verspilt (je krijgt hier geen extra punten voor). De assets zijn niet het belangrijkste, maar kunnen wel tijdrovend zijn.

Vereisten
In deze sectie maken we nogmaals een opsomming van wat wij verwachten van je eindresultaat. Je kan dit gebruiken als een todo-lijst om bij te houden wat je reeds hebt geïmplementeerd en wat je nog moet toevoegen. Dit is een lijst met alle minima. Je project moet minstens voldoen aan deze eisen. We maken verder onderscheid tussen de functionele en niet-functionele vereisten.
Functionele vereisten
Parsen van een wereldbestand naar een spelobject
Renderen van alle spelobjecten (Levels, objecten, entiteiten, ...)
Een startscherm met de mogelijkheid om een level te selecteren
Eindscherm dat aangeeft of alle levels werden uitgespeeld
Speler kan bewegen door de wereld
TODO
Speler kan kisten bewegen
Er kunnen meerdere spelers aanwezig zijn in een wereld
Je moet alle spelers kunnen selecteren en besturen
Drie functionaliteiten uit de onderstaande lijst
TODO
Voor een uitgebreidere uitleg verwijzen we nogmaals naar de functionele vereisten van de engine hierboven.
Niet-functionele vereisten
Naast de basisfunctionaliteit vragen we enkele niet functionele eisen waar je project aan dient te voldoen. Deze niet functionele eisen zijn even belangrijk als de functionele eisen van het project.
Dit project test je kennis over Parsing, Monads en Monad transformers.&nbsp; Je project moet gebruik maken van minstens één monad transformer.&nbsp; Dit project laat zeker toe om al deze concepten te gaan combineren. We zullen zeker kijken of je implementatie deze concepten correct heeft toegepast.
Uiteraard blijven de concepten uit het eerste en tweede project ook bruikbaar en belangrijk.
Je code moet goed gedocumenteerd zijn.
Je code moet getest zijn, dit wil zeggen dat je voor je code zelf testen schrijft, zodat je zeker bent dat de basis functionaliteit werkt. Gebruik hiervoor bijvoorbeeld HSpec. Probeer dit niet uit te stellen tot het einde van je project. Deze testen kunnen je tijdens de ontwikkeling helpen om fouten vroeger te ontdekken.
Verslag (TODO)
We verwachten een bondig verslag van 2 tot 5 pagina's die de implementatie van je engine kort beschrijft. Je verslag wordt in combinatie met je code gelezen. Je kan dus steeds naar de relevante code verwijzen aan de hand van een bestandsnaam en lijnnummer. Je hebt zelf de vrijheid over de opbouw van dit verslag, maar we verwachten op zijn minst de volgende onderdelen.
Een korte inleiding
Architectuur van je engine
Bespreek het gebruik van monads / monad stacks binnen je implementatie.
Bespreek een voorbeeldlevel waarin alle functionaliteit van je project aanwezig is.
Kort overzicht van je testen. Wat heb je getest binnen je project.
Conclusie (wat heb je goed gedaan en wat zou je nog kunnen verbeteren)
Voeg je verslag in PDF-formaat toe als verslag.pdf aan de wortel van je repository.
Tijdsbesteding
We verwachten dat je ongeveer 24 tot 32 uur tijd zal nodig hebben om dit project af te werken.


Het hele&nbsp; project in zijn totaliteit kan misschien te veel lijken om aan te beginnen. We raden aan dat je werkt in kleine stappen.&nbsp; Het is een goed idee om te beginnen met de&nbsp; levellayout te parsen en renderen en vervolgens steeds extra zaken toe te voegen zoals de speler, items en entities. Op die manier kan je steeds werken in kleine stappen en is het eenvoudiger om te bepalen waar het fout loopt.


Merk je tijdens de implementatie dat&nbsp; je veel meer tijd aan het spenderen bent dan 32 uur, vraag je best om meer uitleg. Niet inbegrepen is de tijd die je nodig hebt om de belangrijke concepten van Haskell zelf te leren. Met dit project testen we of je deze concepten kan toepassen.
Codeerstijl
Enkele aandachtspunten bij het schrijven van Haskell-code die we verwachten van jullie code.
Geen hardgecodeerde constanten in je code.
Vermijd het gebruik van if-else constructies. Maak gebruik van pattern matching en guards.
Gebruik where-clausules voor lokale functies.
Probeer, waar mogelijk, gebruik te maken van bestaande functies voor lijsten.
Pas hlint toe op je code
Voldoet je code niet aan de verwachte codestijl zal je hiervoor punten verliezen.
Algemene richtlijnen en indienen
Naast alle logica en render-functionaliteit verwachten we bij dit project dat je functionaliteit zo volledig mogelijk is getest.
Schrijf efficiënte code, maar ga niet over-optimaliseren: geef de voorkeur aan elegante, goed leesbare code. Voorzie voldoende commentaar en vul de bestaande commentaar aan indien nodig.
Projecten die ons niet bereiken voor de deadline worden niet meer verbeterd: dit betekent het verlies van alle te behalen punten voor het project. Hou dus goed rekening met opgelegde deadline.
Dit is een individueel project en dient dus door jou persoonlijk gemaakt te worden. Het is ten strengste verboden code uit te wisselen, op welke manier dan ook. Het overnemen van code beschouwen we als fraude (van beide betrokken partijen) en zal in overeenstemming met het examenreglement behandeld worden. Het overnemen of aanpassen van code van andere bronnen zonder referentie is niet toegelaten en wordt gezien als fraude.
Om ons werk te sparen tijdens het verbeteren, zorgen jullie er zelf voor dat jullie projecten compileren en slagen voor de minimale vereisten. Projecten die niet compileren krijgen automatisch een nul. Om een “maar op mijn machine werkte het wel...” te vermijden, werken we voor dit project met SubGIT.
Met dit project kan je 12 van de 20 punten verdienen voor het projectgedeelte van&nbsp; Functioneel Programmeren.
De deadline voor dit project is 23 december om 22 uur.
Problemen kan je altijd (voor de deadline) melden.


</jouw>